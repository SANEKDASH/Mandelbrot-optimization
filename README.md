# Оптимизация программы, рисующей множество [Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0)

## Введение

Здравствуйте!

На этот раз передо мной стояли следующие задачи:
1) Создать программу, рисующую __множество Мандельброта__.

2) __Оптимизировать__ ее настолько, насколько позволяют возможности мои и моего компьютера.

3) Разузнать о __различиях__ между временами рисования множества Мандельброта в зависимости от используемого буфера.

## Реализация
Для рисования использовалась графическая библиотека SFML.


Мною было написано две версии функций, рисующих множество Мандельброта.

__Первая__ - без оптимизаций.

__Вторая__ - получена из первой использованием возможностями процессора выполнять однотипные операции для массива данных за больший throughput (SIMD instructions).

> [!IMPORTANT]
> Оптимизация проводилась конкретно под мой процессор (Intel core i5 11400H).
> Полученные данные измерений на моей и вашей машине могут различаться.
> Так же влияют и некоторые внешние факторы (загруженность компьютера во время измерения, температура помещения,
> где вы проводите измерения, степень загрязнения пылью вашего ПК и т.д.
>
> Еще стоит отметить, что флаг -O3(-O2) - обязателен для __эффективной__ работы simd инструкций. Так как без них работа сильно замедляется.

## Установка
Эта программа реализована для ОС Linux.

Для установки вам понадобится установить библиотеку SFML и компилятор g++ на свой компьютер.
Для этого введите в терминал следующие команды:

```shell
sudo apt update

sudo apt install build-essential

sudo apt-get install libsfml-dev
```

Далее вам нужно склонировать этот репозиторий. Это делается следующей
командой:

```shell

git clone git@github.com:SANEKDASH/Mandelbrot-optimization.git

```

Дело осталось за малым. Теперь вам нужно зайти в папку с ранее склонированным репозиторием и запустить __MakeFile__ из терминала.
Делается это следующим образом:

```shell
make -f MakeFile
```

Вам осталось только запустить файл "Mandelbrot" и наслаждаться прекрасными
фракталами.

## Измерения
Для измерений я сделал скрипт на языке Python, который генерирует MakeFile для каждой исследуемой версии программы.
Далее он запускает исполняемый файл, полученный после компиляции, и собирает соответствующие данные.

Измерения проводятся под флагами: -O3, -march=native (-DAVX_IMPLEMENT, -SFML_BUFFER - для каждого измерения - своя комбинация этих флагов).

Измерения будем проводить для двух подреализаций:
1) Для рисования напрямую используется буфер SFML. (флаг -DSFML_BUFFER)
2) Для рисования используется массив с цветами для каждого пикселя картинки.(флага -DSFML_BUFFER - нет)

Количиство __тиков__ измеряется с помощью так называемой intrinsic function [_rdtsc()](https://www.laruence.com/sse/#expand=9,1012,94,12,15,2580,3946,12,13,14,124,4932,124,4930,4980,3931,5023,744,5730,743,744,4546,4545&text=__int64%20_rdtsc%20(void)).

Для уменьшения влияния случайной погрешности измерения проводились 100 раз, затем бралось среднее значение.

Полученные данные можно увидеть в [таблице](https://docs.google.com/spreadsheets/d/1AN8wLIET6k-PCWs7dYyGhULIfOBxHbarKt0lwydywe8/edit?usp=sharing).

### Буфер SFML

Для начала, измерим количество __тиков__ процессора, расходуемое на работу этих функций в
__первой__ подреализации.

График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/gavno0.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/gavno1.png)

Видим, что оба значения кол-ва тиков не зависят от номера измерения. Следовательно, можем взять для каждого среднее и получить окончательно:

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|__(1446 +- 4) * 10 ^6__|__(1064 +- 3) * 10 ^ 6__|

Видим, ускорение в 1.36 раз. Это может говорить о том, что сам алгоритм обсчета/отрисовки мы ускорили, но есть какие-то другие процессы, выполняемые процессором, на которые мы не можем повлиять, либо не учли.

### Буфер с цветами пикселей
График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/gavno2.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/gavno3.png)

Так же, как и в предыдущем пункте, заметна независимость кол-ва тиков от номера измерения. Значит можем усреднить полученные значения и получить следующее:

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|__(1350 +- 2) * 10 ^ 5__|__(249 +- 9) * 10 ^ 5__|

Полученные данные свидетельствуют об ускорении в __5,43__ раз.
Для сравнения, предыдущий показатель - __1.36__.
Так как векторизация для SIMD инструкций бралась по 8 значений, можно сказать,
что в программе все еще присутствует какая-то часть, в которую упирается наша оптимизация.


## Обсудим результаты

При переходе от буфера SFML к буферу с цветами пикселей получились следующие ускорения:
1) Векторизованная версия - __42.8__
2) Рисование по точкам - __10.7__

Из этого можем сделать вывод, что пользоваться буфером с цветами пикселей все же лучше.

Различия в производительности между подреализациями можно описать следующим образом.

Они заключаются в использовании функции библиотеки SFML __window.draw()__.
В первой она используется в цикле и рисует по пикселям (прямоугольники размером 1x1 пиксель).
Во второй используется лишь для того, чтобы нарисовать спрайт, созданный на основе массива цветов.

Судя по всему функция __window.draw()__ достаточно тяжела для выполнения.
Отсюда и берутся такие значительные различия в количествах тиков.

При сочетании использования буфера с цветами пикселей
и SIMD инструкций получилось ускорение в 58.2 раза.

В целом, результат получился неплохой.

## Источники
1) Теория о множестве Мандельброта https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0
2) Документация на intrinsic functions https://www.laruence.com/sse/#expand=9,1012,94,12,15,2580,3946,12,13,14,124,4932,124,4930,4980,3931,5023,744,5730,743,744,4546,4545
