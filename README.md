# Оптимизация [Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0)

## Введение

Здравствуйте!

На этот раз передо мной стояли следующие задачи:
1) Создать программу, рисующую __множество Мандельброта__.

2) __Оптимизировать__ ее настолько, насколько позволяют возможности мои и моего компьютера.

3) Разузнать о __различиях__ между временами рисования множества Мандельброта в зависимости от используемого буфера.

## Реализация
Для рисования использовалась графическая библиотека SFML.


Мною было написано две версии функций, рисующих множество Мандельброта.

__Первая__ - без оптимизаций.

__Вторая__ - получена из первой использованием возможностями процессора выполнять однотипные операции для массива данных за малое кол-во тактов (SIMD instructions).

<font color = red>

__ВАЖНО__

Оптимизация праводилась конкретно под мой процессор (Intel core i5 11400H).

Полученные данные измерений на моей и вашей машине могут различаться.
Так же влияют и некоторые внешние факторы (температура помещения,
где вы проводите измерения, степень загрязнения пылью вашего ПК и т.д.)

</font>

## Измерения
Измерения будем проводить для двух подреализаций:
1) Для рисование напрямую исполюзуется буфер SFML.
2) Для рисования используется массив с цветами для каждого пикселя картинки.

Количиство __тиков__ (що?) измеряется с помощью так называемой intrinsic function [_rdtsc()](https://www.laruence.com/sse/#expand=9,1012,94,12,15,2580,3946,12,13,14,124,4932,124,4930,4980,3931,5023,744,5730,743,744,4546,4545&text=__int64%20_rdtsc%20(void)).

Для уменьшения влияния случайной погрешности измерения проводились 100 раз, затем бралось среднее значение.

Полученные данные можно увидеть в [таблице](https://docs.google.com/spreadsheets/d/1AN8wLIET6k-PCWs7dYyGhULIfOBxHbarKt0lwydywe8/edit?usp=sharing) .

### Первая подреализация

Для начала, измерим количество __тиков__ процессора, расходуемое на работу этих функций в
__первой__ подреализации.

График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/mandelbrot_graph0.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/mandelbrot_graph1.png)

Видим, что оба значения кол-ва тиков не зависят от номера измерения. Следовательно можем взять для каждого среднее и получить окончательно.

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|1227278613 +- 29725242|1037136414 +- 18188309|

Видим, что количество тиков после оптимизации уменьшилось в 1.18 раз. Это может говорить о том, что сам алгоритм обсчета/отрисовки мы ускорили, но есть какие-то другие процессы, выполняемые процессором, на которые мы не можем повлиять, либо не учли.

### Вторая подреализация
График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/mandelbrot_graph3.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/mandelbrot_graph4.png)

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|999706202  +- 38979621|90066678 +- 196142|

Полученные данные свидетельствуют о понижении кол-ва тиков в 11.09 раз.
Это не идет ни в какое сравнение с предыдущим показателем (1.18).
В целом этот результат можно считать ожидаемым, так как векторизация для SIMD
инструкций бралась по 8 значений.

## Обсудим результаты

Такой поразительный прирост во второй подреализации можно описать следующим образом.

