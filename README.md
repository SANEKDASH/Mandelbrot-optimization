# Оптимизация программы, рисующей множество [Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0)

## Введение

Здравствуйте!

На этот раз передо мной стояли следующие задачи:
1) Создать программу, рисующую __множество Мандельброта__.

2) __Оптимизировать__ ее настолько, насколько позволяют возможности мои и моего компьютера.

3) Разузнать о __различиях__ между временами рисования множества Мандельброта в зависимости от используемого буфера.

## Реализация
Для рисования использовалась графическая библиотека SFML.


Мною было написано две версии функций, рисующих множество Мандельброта.

__Первая__ - без оптимизаций.

__Вторая__ - получена из первой использованием возможностями процессора выполнять однотипные операции для массива данных за малое кол-во тактов (SIMD instructions).

> [!IMPORTANT]
> Оптимизация проводилась конкретно под мой процессор (Intel core i5 11400H).
> Полученные данные измерений на моей и вашей машине могут различаться.
> Так же влияют и некоторые внешние факторы (температура помещения,
> где вы проводите измерения, степень загрязнения пылью вашего ПК и т.д.)

## Установка
Для установки вам понадобится установить библиотеку SFML и компилятор g++ на свой компьютер.
Для этого введите в терминал следующие команды:

```shell
sudo apt update

sudo apt install build-essential

sudo apt-get install libsfml-dev
```

Далее вам нужно склонировать этот репозиторий. Это делается следующей
командой:

```shell

git clone git@github.com:SANEKDASH/Mandelbrot-optimization.git

```

Дело осталось за малым. Теперь вам нужно зайти в папку с ранее склонированным репозиторием и запустить __MakeFile__ из терминала.
Делается это следующим образом:

```shell
make -f MakeFile
```

Вам осталось только запустить файл "Mandelbrot" и наслаждаться прекрасными
фракталами.

## Измерения
Для измерений я сделал скрипт на языке Python, который генерирует MakeFile для каждой исследуемой версии программы.
Далее он запускает исполняемый файл, полученный после компиляции, и собирает соответствующие данные.

Измерения будем проводить для двух подреализаций:
1) Для рисования напрямую используется буфер SFML.
2) Для рисования используется массив с цветами для каждого пикселя картинки.

Количиство __тиков__ измеряется с помощью так называемой intrinsic function [_rdtsc()](https://www.laruence.com/sse/#expand=9,1012,94,12,15,2580,3946,12,13,14,124,4932,124,4930,4980,3931,5023,744,5730,743,744,4546,4545&text=__int64%20_rdtsc%20(void)).

Для уменьшения влияния случайной погрешности измерения проводились 100 раз, затем бралось среднее значение.

Полученные данные можно увидеть в [таблице](https://docs.google.com/spreadsheets/d/1AN8wLIET6k-PCWs7dYyGhULIfOBxHbarKt0lwydywe8/edit?usp=sharing) .

### Буфер SFML

Для начала, измерим количество __тиков__ процессора, расходуемое на работу этих функций в
__первой__ подреализации.

График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/auto_mandelbrot_graph2.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/auto_mandelbrot_graph3.png)

Видим, что оба значения кол-ва тиков не зависят от номера измерения. Следовательно, можем взять для каждого среднее и получить окончательно:

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|__1446544710 +- 3524624__|__1063880833 +- 2935487__|

Видим, что количество тиков после оптимизации уменьшилось в 1.36 раз. Это может говорить о том, что сам алгоритм обсчета/отрисовки мы ускорили, но есть какие-то другие процессы, выполняемые процессором, на которые мы не можем повлиять, либо не учли.

### Буфер с цветами пикселей
График зависимости кол-ва тиков от номера измерения
для версии без оптимизации
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/auto_mandelbrot_graph0.png)


График зависимости кол-ва тиков от номера измерения
для версии с оптимизацией
![Alt text](https://github.com/SANEKDASH/Mandelbrot-optimization/blob/main/readme_src/auto_mandelbrot_graph1.png)

Так же, как и в предыдущем пункте, заметна независимость кол-ва тиков от номера измерения. Значит можем усреднить полученные значения и получить следующее:

|              |    без оптимизации     |     с оптимизацией     |
|--------------|:----------------------:|:----------------------:|
|время работы (в тиках)|__135016470  +- 165700__|__24851212 +- 87667__|



Полученные данные свидетельствуют о понижении кол-ва тиков в __5,43__ раз.
Для сравнения, предыдущий показатель - __1.36__.
Так как векторизация для SIMD инструкций бралась по 8 значений, можно сказать,
что в программе все еще присутствует какая-то часть, в которую упирается наша оптимизация.


## Обсудим результаты

В целом программу получилось ускорить в 58.2 раза.

Мне кажется, это неплохой результат.

При переходе от буфера SFML к буферу с цветами пикселей получились следующие улучшения производительности:
1) Векторизованная версия - __42.8__
2) Рисование по точкам - __10.7__

Из этого можем сделать вывод, что пользоваться буфером с цветами пикселей все же лучше.

Различия в производительности между подреализациями можно описать следующим образом.

Они заключаются в использовании функции библиотеки SFML __window.draw()__.
В первой она используется в цикле и рисует по пикселям (прямоугольники размером 1x1 пиксель).
Во второй используется лишь для того, чтобы нарисовать спрайт, созданный на основе массива цветов.

Судя по всему функция __window.draw()__ достаточно тяжела для выполнения.
Отсюда и берутся такие значительные различия в количествах тиков.

